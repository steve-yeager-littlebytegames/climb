/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.19.1.0 (NJsonSchema v9.10.72.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
export var ClimbClient;
(function (ClimbClient) {
    class BaseClass {
        getBaseUrl(defaultUrl) {
            return window.location.origin;
        }
        getAuthorizationToken() {
            return localStorage.getItem("jwt");
        }
    }
    ClimbClient.BaseClass = BaseClass;
    class Admin extends BaseClass {
        constructor(baseUrl, http) {
            super();
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("http://localhost:44320");
        }
        migrate(key) {
            let url_ = this.baseUrl + "/admin/data/migrate";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "key": key !== undefined && key !== null ? "" + key : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processMigrate(_response);
            });
        }
        processMigrate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        updateAllLeagues(key) {
            let url_ = this.baseUrl + "/admin/update-all-leagues";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "key": key !== undefined && key !== null ? "" + key : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processUpdateAllLeagues(_response);
            });
        }
        processUpdateAllLeagues(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200 || status === 206) {
                const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
                const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
                return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    ClimbClient.Admin = Admin;
    class AccountApi extends BaseClass {
        constructor(baseUrl, http) {
            super();
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("http://localhost:44320");
        }
        register(email, username, name, password, confirmPassword, rememberMe) {
            let url_ = this.baseUrl + "/api/v1/account/register?";
            if (email === undefined)
                throw new Error("The parameter 'email' must be defined.");
            else
                url_ += "email=" + encodeURIComponent("" + email) + "&";
            if (username === undefined)
                throw new Error("The parameter 'username' must be defined.");
            else
                url_ += "username=" + encodeURIComponent("" + username) + "&";
            if (name !== undefined)
                url_ += "name=" + encodeURIComponent("" + name) + "&";
            if (password === undefined)
                throw new Error("The parameter 'password' must be defined.");
            else
                url_ += "password=" + encodeURIComponent("" + password) + "&";
            if (confirmPassword !== undefined)
                url_ += "confirmPassword=" + encodeURIComponent("" + confirmPassword) + "&";
            if (rememberMe === undefined || rememberMe === null)
                throw new Error("The parameter 'rememberMe' must be defined and cannot be null.");
            else
                url_ += "rememberMe=" + encodeURIComponent("" + rememberMe) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processRegister(_response);
            });
        }
        processRegister(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201 = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = resultData201 ? UserDto.fromJS(resultData201) : new UserDto();
                    return result201;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        logIn(email, password, rememberMe) {
            let url_ = this.baseUrl + "/api/v1/account/logIn?";
            if (email === undefined)
                throw new Error("The parameter 'email' must be defined.");
            else
                url_ += "email=" + encodeURIComponent("" + email) + "&";
            if (password === undefined)
                throw new Error("The parameter 'password' must be defined.");
            else
                url_ += "password=" + encodeURIComponent("" + password) + "&";
            if (rememberMe === undefined || rememberMe === null)
                throw new Error("The parameter 'rememberMe' must be defined and cannot be null.");
            else
                url_ += "rememberMe=" + encodeURIComponent("" + rememberMe) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processLogIn(_response);
            });
        }
        processLogIn(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : null;
                    return result200;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        test(authorization, userID) {
            let url_ = this.baseUrl + "/api/v1/account/test?";
            if (userID === undefined)
                throw new Error("The parameter 'userID' must be defined.");
            else
                url_ += "userID=" + encodeURIComponent("" + userID) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processTest(_response);
            });
        }
        processTest(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : null;
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        logout(authorization) {
            let url_ = this.baseUrl + "/api/v1/account/logOut";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Authorization": authorization !== undefined && authorization !== null ? "" + authorization : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processLogout(_response);
            });
        }
        processLogout(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : null;
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    ClimbClient.AccountApi = AccountApi;
    class GameApi extends BaseClass {
        constructor(baseUrl, http) {
            super();
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("http://localhost:44320");
        }
        get(gameID) {
            let url_ = this.baseUrl + "/api/v1/games/{gameID}";
            if (gameID === undefined || gameID === null)
                throw new Error("The parameter 'gameID' must be defined.");
            url_ = url_.replace("{gameID}", encodeURIComponent("" + gameID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? GameDto.fromJS(resultData200) : new GameDto();
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        listAll() {
            let url_ = this.baseUrl + "/api/v1/games";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processListAll(_response);
            });
        }
        processListAll(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (resultData200 && resultData200.constructor === Array) {
                        result200 = [];
                        for (let item of resultData200)
                            result200.push(GameDto.fromJS(item));
                    }
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    ClimbClient.GameApi = GameApi;
    class LeagueApi extends BaseClass {
        constructor(baseUrl, http) {
            super();
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("http://localhost:44320");
        }
        listAll() {
            let url_ = this.baseUrl + "/api/v1/leagues";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processListAll(_response);
            });
        }
        processListAll(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (resultData200 && resultData200.constructor === Array) {
                        result200 = [];
                        for (let item of resultData200)
                            result200.push(LeagueDto.fromJS(item));
                    }
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        get(leagueID) {
            let url_ = this.baseUrl + "/api/v1/leagues/{leagueID}";
            if (leagueID === undefined || leagueID === null)
                throw new Error("The parameter 'leagueID' must be defined.");
            url_ = url_.replace("{leagueID}", encodeURIComponent("" + leagueID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? LeagueDto.fromJS(resultData200) : new LeagueDto();
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        create(gameID, name, adminID) {
            let url_ = this.baseUrl + "/api/v1/leagues/create?";
            if (gameID === undefined || gameID === null)
                throw new Error("The parameter 'gameID' must be defined and cannot be null.");
            else
                url_ += "gameID=" + encodeURIComponent("" + gameID) + "&";
            if (name === undefined)
                throw new Error("The parameter 'name' must be defined.");
            else
                url_ += "name=" + encodeURIComponent("" + name) + "&";
            if (adminID !== undefined)
                url_ += "adminID=" + encodeURIComponent("" + adminID) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201 = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = resultData201 ? LeagueDto.fromJS(resultData201) : new LeagueDto();
                    return result201;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status === 409) {
                return response.text().then((_responseText) => {
                    let result409 = null;
                    let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result409 = resultData409 !== undefined ? resultData409 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result409);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        join(leagueID, userID) {
            let url_ = this.baseUrl + "/api/v1/leagues/join?";
            if (leagueID === undefined || leagueID === null)
                throw new Error("The parameter 'leagueID' must be defined and cannot be null.");
            else
                url_ += "leagueID=" + encodeURIComponent("" + leagueID) + "&";
            if (userID === undefined)
                throw new Error("The parameter 'userID' must be defined.");
            else
                url_ += "userID=" + encodeURIComponent("" + userID) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processJoin(_response);
            });
        }
        processJoin(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201 = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = resultData201 ? LeagueUserDto.fromJS(resultData201) : new LeagueUserDto();
                    return result201;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        getUser(userID) {
            let url_ = this.baseUrl + "/api/v1/leagues/user/{userID}";
            if (userID === undefined || userID === null)
                throw new Error("The parameter 'userID' must be defined.");
            url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processGetUser(_response);
            });
        }
        processGetUser(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? LeagueUserDto.fromJS(resultData200) : new LeagueUserDto();
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        getSeasons(leagueID) {
            let url_ = this.baseUrl + "/api/v1/leagues/seasons/{leagueID}";
            if (leagueID === undefined || leagueID === null)
                throw new Error("The parameter 'leagueID' must be defined.");
            url_ = url_.replace("{leagueID}", encodeURIComponent("" + leagueID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processGetSeasons(_response);
            });
        }
        processGetSeasons(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (resultData200 && resultData200.constructor === Array) {
                        result200 = [];
                        for (let item of resultData200)
                            result200.push(SeasonDto.fromJS(item));
                    }
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * @param key (optional)
         * @return League power rankings have been updated.
         */
        updateStandings(leagueID, key) {
            let url_ = this.baseUrl + "/api/v1/leagues/update-standings/{leagueID}";
            if (leagueID === undefined || leagueID === null)
                throw new Error("The parameter 'leagueID' must be defined.");
            url_ = url_.replace("{leagueID}", encodeURIComponent("" + leagueID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "key": key !== undefined && key !== null ? "" + key : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processUpdateStandings(_response);
            });
        }
        processUpdateStandings(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? LeagueDto.fromJS(resultData200) : new LeagueDto();
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        leave(leagueUserID) {
            let url_ = this.baseUrl + "/api/v1/leagues/leave?";
            if (leagueUserID === undefined || leagueUserID === null)
                throw new Error("The parameter 'leagueUserID' must be defined and cannot be null.");
            else
                url_ += "leagueUserID=" + encodeURIComponent("" + leagueUserID) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processLeave(_response);
            });
        }
        processLeave(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? LeagueUserDto.fromJS(resultData200) : new LeagueUserDto();
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    ClimbClient.LeagueApi = LeagueApi;
    class SeasonApi extends BaseClass {
        constructor(baseUrl, http) {
            super();
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("http://localhost:44320");
        }
        get(seasonID) {
            let url_ = this.baseUrl + "/api/v1/seasons/{seasonID}";
            if (seasonID === undefined || seasonID === null)
                throw new Error("The parameter 'seasonID' must be defined.");
            url_ = url_.replace("{seasonID}", encodeURIComponent("" + seasonID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? SeasonDto.fromJS(resultData200) : new SeasonDto();
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        sets(seasonID) {
            let url_ = this.baseUrl + "/api/v1/seasons/sets/{seasonID}";
            if (seasonID === undefined || seasonID === null)
                throw new Error("The parameter 'seasonID' must be defined.");
            url_ = url_.replace("{seasonID}", encodeURIComponent("" + seasonID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processSets(_response);
            });
        }
        processSets(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (resultData200 && resultData200.constructor === Array) {
                        result200 = [];
                        for (let item of resultData200)
                            result200.push(SetDto.fromJS(item));
                    }
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        participants(seasonID) {
            let url_ = this.baseUrl + "/api/v1/seasons/participants/{seasonID}";
            if (seasonID === undefined || seasonID === null)
                throw new Error("The parameter 'seasonID' must be defined.");
            url_ = url_.replace("{seasonID}", encodeURIComponent("" + seasonID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processParticipants(_response);
            });
        }
        processParticipants(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (resultData200 && resultData200.constructor === Array) {
                        result200 = [];
                        for (let item of resultData200)
                            result200.push(SeasonLeagueUserDto.fromJS(item));
                    }
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        listForLeague(leagueID) {
            let url_ = this.baseUrl + "/api/v1/seasons?";
            if (leagueID === undefined || leagueID === null)
                throw new Error("The parameter 'leagueID' must be defined and cannot be null.");
            else
                url_ += "leagueID=" + encodeURIComponent("" + leagueID) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processListForLeague(_response);
            });
        }
        processListForLeague(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (resultData200 && resultData200.constructor === Array) {
                        result200 = [];
                        for (let item of resultData200)
                            result200.push(SeasonDto.fromJS(item));
                    }
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        create(leagueID, startDate, endDate) {
            let url_ = this.baseUrl + "/api/v1/seasons/create?";
            if (leagueID === undefined || leagueID === null)
                throw new Error("The parameter 'leagueID' must be defined and cannot be null.");
            else
                url_ += "leagueID=" + encodeURIComponent("" + leagueID) + "&";
            if (startDate === undefined || startDate === null)
                throw new Error("The parameter 'startDate' must be defined and cannot be null.");
            else
                url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
            if (endDate === undefined || endDate === null)
                throw new Error("The parameter 'endDate' must be defined and cannot be null.");
            else
                url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processCreate(_response);
            });
        }
        processCreate(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201 = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = resultData201 ? SeasonDto.fromJS(resultData201) : new SeasonDto();
                    return result201;
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result400);
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        start(seasonID) {
            let url_ = this.baseUrl + "/api/v1/seasons/start?";
            if (seasonID === undefined || seasonID === null)
                throw new Error("The parameter 'seasonID' must be defined and cannot be null.");
            else
                url_ += "seasonID=" + encodeURIComponent("" + seasonID) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processStart(_response);
            });
        }
        processStart(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201 = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (resultData201 && resultData201.constructor === Array) {
                        result201 = [];
                        for (let item of resultData201)
                            result201.push(SetDto.fromJS(item));
                    }
                    return result201;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        end(seasonID) {
            let url_ = this.baseUrl + "/api/v1/seasons/end?";
            if (seasonID === undefined || seasonID === null)
                throw new Error("The parameter 'seasonID' must be defined and cannot be null.");
            else
                url_ += "seasonID=" + encodeURIComponent("" + seasonID) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processEnd(_response);
            });
        }
        processEnd(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? SeasonDto.fromJS(resultData200) : new SeasonDto();
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        leave(participantID) {
            let url_ = this.baseUrl + "/api/v1/seasons/leave?";
            if (participantID === undefined || participantID === null)
                throw new Error("The parameter 'participantID' must be defined and cannot be null.");
            else
                url_ += "participantID=" + encodeURIComponent("" + participantID) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processLeave(_response);
            });
        }
        processLeave(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? SeasonDto.fromJS(resultData200) : new SeasonDto();
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    ClimbClient.SeasonApi = SeasonApi;
    class SetApi extends BaseClass {
        constructor(baseUrl, http) {
            super();
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("http://localhost:44320");
        }
        submit(request) {
            let url_ = this.baseUrl + "/api/v1/sets/submit";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = JSON.stringify(request);
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processSubmit(_response);
            });
        }
        processSubmit(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? SetDto.fromJS(resultData200) : new SetDto();
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400 = null;
                    let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result400);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        get(setID) {
            let url_ = this.baseUrl + "/api/v1/sets/{setID}";
            if (setID === undefined || setID === null)
                throw new Error("The parameter 'setID' must be defined.");
            url_ = url_.replace("{setID}", encodeURIComponent("" + setID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? SetDto.fromJS(resultData200) : new SetDto();
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        challengeUser(requesterID, challengedID, message) {
            let url_ = this.baseUrl + "/api/v1/sets/challenge?";
            if (requesterID === undefined || requesterID === null)
                throw new Error("The parameter 'requesterID' must be defined and cannot be null.");
            else
                url_ += "requesterID=" + encodeURIComponent("" + requesterID) + "&";
            if (challengedID === undefined || challengedID === null)
                throw new Error("The parameter 'challengedID' must be defined and cannot be null.");
            else
                url_ += "challengedID=" + encodeURIComponent("" + challengedID) + "&";
            if (message === undefined)
                throw new Error("The parameter 'message' must be defined.");
            else
                url_ += "message=" + encodeURIComponent("" + message) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processChallengeUser(_response);
            });
        }
        processChallengeUser(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201 = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = resultData201 ? SetRequestDto.fromJS(resultData201) : new SetRequestDto();
                    return result201;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        respondToChallenge(requestID, accept) {
            let url_ = this.baseUrl + "/api/v1/sets/respondToChallenge?";
            if (requestID === undefined || requestID === null)
                throw new Error("The parameter 'requestID' must be defined and cannot be null.");
            else
                url_ += "requestID=" + encodeURIComponent("" + requestID) + "&";
            if (accept === undefined || accept === null)
                throw new Error("The parameter 'accept' must be defined and cannot be null.");
            else
                url_ += "accept=" + encodeURIComponent("" + accept) + "&";
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processRespondToChallenge(_response);
            });
        }
        processRespondToChallenge(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? SetRequestDto.fromJS(resultData200) : new SetRequestDto();
                    return result200;
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    ClimbClient.SetApi = SetApi;
    class UserApi extends BaseClass {
        constructor(baseUrl, http) {
            super();
            this.jsonParseReviver = undefined;
            this.http = http ? http : window;
            this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("http://localhost:44320");
        }
        get(userID) {
            let url_ = this.baseUrl + "/api/v1/users/{userID}";
            if (userID === undefined || userID === null)
                throw new Error("The parameter 'userID' must be defined.");
            url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
            url_ = url_.replace(/[?&]$/, "");
            let options_ = {
                method: "GET",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processGet(_response);
            });
        }
        processGet(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200 = null;
                    let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
                    return result200;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
        /**
         * @param image (optional)
         * @return Profile picture URL.
         */
        uploadProfilePic(userID, image) {
            let url_ = this.baseUrl + "/api/v1/users/uploadProfilePic?";
            if (userID === undefined)
                throw new Error("The parameter 'userID' must be defined.");
            else
                url_ += "userID=" + encodeURIComponent("" + userID) + "&";
            url_ = url_.replace(/[?&]$/, "");
            const content_ = new FormData();
            if (image !== null && image !== undefined)
                content_.append("image", image.data, image.fileName ? image.fileName : "image");
            let options_ = {
                body: content_,
                method: "POST",
                headers: {
                    "Accept": "application/json"
                }
            };
            return this.http.fetch(url_, options_).then((_response) => {
                return this.processUploadProfilePic(_response);
            });
        }
        processUploadProfilePic(response) {
            const status = response.status;
            let _headers = {};
            if (response.headers && response.headers.forEach) {
                response.headers.forEach((v, k) => _headers[k] = v);
            }
            ;
            if (status === 201) {
                return response.text().then((_responseText) => {
                    let result201 = null;
                    let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result201 = resultData201 !== undefined ? resultData201 : null;
                    return result201;
                });
            }
            else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404 = null;
                    let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : null;
                    return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            }
            else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve(null);
        }
    }
    ClimbClient.UserApi = UserApi;
    class UserDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.username = data["username"];
                this.email = data["email"];
                this.profilePic = data["profilePic"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new UserDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["username"] = this.username;
            data["email"] = this.email;
            data["profilePic"] = this.profilePic;
            return data;
        }
    }
    ClimbClient.UserDto = UserDto;
    class GameDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
            if (!data) {
                this.characters = [];
                this.stages = [];
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.name = data["name"];
                if (data["characters"] && data["characters"].constructor === Array) {
                    this.characters = [];
                    for (let item of data["characters"])
                        this.characters.push(CharacterDto.fromJS(item));
                }
                if (data["stages"] && data["stages"].constructor === Array) {
                    this.stages = [];
                    for (let item of data["stages"])
                        this.stages.push(StageDto.fromJS(item));
                }
                this.charactersPerMatch = data["charactersPerMatch"];
                this.scoreName = data["scoreName"];
                this.matchName = data["matchName"];
                this.maxMatchPoints = data["maxMatchPoints"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new GameDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["name"] = this.name;
            if (this.characters && this.characters.constructor === Array) {
                data["characters"] = [];
                for (let item of this.characters)
                    data["characters"].push(item.toJSON());
            }
            if (this.stages && this.stages.constructor === Array) {
                data["stages"] = [];
                for (let item of this.stages)
                    data["stages"].push(item.toJSON());
            }
            data["charactersPerMatch"] = this.charactersPerMatch;
            data["scoreName"] = this.scoreName;
            data["matchName"] = this.matchName;
            data["maxMatchPoints"] = this.maxMatchPoints;
            return data;
        }
    }
    ClimbClient.GameDto = GameDto;
    class CharacterDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.name = data["name"];
                this.picture = data["picture"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new CharacterDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["name"] = this.name;
            data["picture"] = this.picture;
            return data;
        }
    }
    ClimbClient.CharacterDto = CharacterDto;
    class StageDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.name = data["name"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new StageDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["name"] = this.name;
            return data;
        }
    }
    ClimbClient.StageDto = StageDto;
    class LeagueDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.gameID = data["gameID"];
                this.organizationID = data["organizationID"];
                this.name = data["name"];
                this.setsTillRank = data["setsTillRank"];
                this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : undefined;
                this.adminID = data["adminID"];
                this.activeSeasonID = data["activeSeasonID"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new LeagueDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["gameID"] = this.gameID;
            data["organizationID"] = this.organizationID;
            data["name"] = this.name;
            data["setsTillRank"] = this.setsTillRank;
            data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : undefined;
            data["adminID"] = this.adminID;
            data["activeSeasonID"] = this.activeSeasonID;
            return data;
        }
    }
    ClimbClient.LeagueDto = LeagueDto;
    class LeagueUserDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.leagueID = data["leagueID"];
                this.userID = data["userID"];
                this.hasLeft = data["hasLeft"];
                this.username = data["username"];
                this.points = data["points"];
                this.rank = data["rank"];
                this.profilePicture = data["profilePicture"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new LeagueUserDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["leagueID"] = this.leagueID;
            data["userID"] = this.userID;
            data["hasLeft"] = this.hasLeft;
            data["username"] = this.username;
            data["points"] = this.points;
            data["rank"] = this.rank;
            data["profilePicture"] = this.profilePicture;
            return data;
        }
    }
    ClimbClient.LeagueUserDto = LeagueUserDto;
    class SeasonDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.leagueID = data["leagueID"];
                this.index = data["index"];
                this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : undefined;
                this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : undefined;
                this.isActive = data["isActive"];
                this.isComplete = data["isComplete"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new SeasonDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["leagueID"] = this.leagueID;
            data["index"] = this.index;
            data["startDate"] = this.startDate ? this.startDate.toISOString() : undefined;
            data["endDate"] = this.endDate ? this.endDate.toISOString() : undefined;
            data["isActive"] = this.isActive;
            data["isComplete"] = this.isComplete;
            return data;
        }
    }
    ClimbClient.SeasonDto = SeasonDto;
    class SetDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
            if (!data) {
                this.matches = [];
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.leagueID = data["leagueID"];
                this.leagueName = data["leagueName"];
                this.seasonID = data["seasonID"];
                this.gameID = data["gameID"];
                this.player1ID = data["player1ID"];
                this.player2ID = data["player2ID"];
                this.player1Score = data["player1Score"];
                this.player2Score = data["player2Score"];
                this.dueDate = data["dueDate"] ? new Date(data["dueDate"].toString()) : undefined;
                this.updatedDate = data["updatedDate"] ? new Date(data["updatedDate"].toString()) : undefined;
                if (data["matches"] && data["matches"].constructor === Array) {
                    this.matches = [];
                    for (let item of data["matches"])
                        this.matches.push(MatchDto.fromJS(item));
                }
                this.isLocked = data["isLocked"];
                this.isComplete = data["isComplete"];
                this.setType = data["setType"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new SetDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["leagueID"] = this.leagueID;
            data["leagueName"] = this.leagueName;
            data["seasonID"] = this.seasonID;
            data["gameID"] = this.gameID;
            data["player1ID"] = this.player1ID;
            data["player2ID"] = this.player2ID;
            data["player1Score"] = this.player1Score;
            data["player2Score"] = this.player2Score;
            data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : undefined;
            data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : undefined;
            if (this.matches && this.matches.constructor === Array) {
                data["matches"] = [];
                for (let item of this.matches)
                    data["matches"].push(item.toJSON());
            }
            data["isLocked"] = this.isLocked;
            data["isComplete"] = this.isComplete;
            data["setType"] = this.setType;
            return data;
        }
    }
    ClimbClient.SetDto = SetDto;
    class MatchDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
            if (!data) {
                this.player1Characters = [];
                this.player2Characters = [];
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.index = data["index"];
                this.player1Score = data["player1Score"];
                this.player2Score = data["player2Score"];
                if (data["player1Characters"] && data["player1Characters"].constructor === Array) {
                    this.player1Characters = [];
                    for (let item of data["player1Characters"])
                        this.player1Characters.push(item);
                }
                if (data["player2Characters"] && data["player2Characters"].constructor === Array) {
                    this.player2Characters = [];
                    for (let item of data["player2Characters"])
                        this.player2Characters.push(item);
                }
                this.stageID = data["stageID"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new MatchDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["index"] = this.index;
            data["player1Score"] = this.player1Score;
            data["player2Score"] = this.player2Score;
            if (this.player1Characters && this.player1Characters.constructor === Array) {
                data["player1Characters"] = [];
                for (let item of this.player1Characters)
                    data["player1Characters"].push(item);
            }
            if (this.player2Characters && this.player2Characters.constructor === Array) {
                data["player2Characters"] = [];
                for (let item of this.player2Characters)
                    data["player2Characters"].push(item);
            }
            data["stageID"] = this.stageID;
            return data;
        }
    }
    ClimbClient.MatchDto = MatchDto;
    let SetTypes;
    (function (SetTypes) {
        SetTypes[SetTypes["Challenge"] = 0] = "Challenge";
        SetTypes[SetTypes["Season"] = 1] = "Season";
    })(SetTypes = ClimbClient.SetTypes || (ClimbClient.SetTypes = {}));
    class SeasonLeagueUserDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.seasonID = data["seasonID"];
                this.leagueUserID = data["leagueUserID"];
                this.userID = data["userID"];
                this.standing = data["standing"];
                this.points = data["points"];
                this.tieBreakerPoints = data["tieBreakerPoints"];
                this.hasLeft = data["hasLeft"];
                this.profilePic = data["profilePic"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new SeasonLeagueUserDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["seasonID"] = this.seasonID;
            data["leagueUserID"] = this.leagueUserID;
            data["userID"] = this.userID;
            data["standing"] = this.standing;
            data["points"] = this.points;
            data["tieBreakerPoints"] = this.tieBreakerPoints;
            data["hasLeft"] = this.hasLeft;
            data["profilePic"] = this.profilePic;
            return data;
        }
    }
    ClimbClient.SeasonLeagueUserDto = SeasonLeagueUserDto;
    class SubmitRequest {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
            if (!data) {
                this.matches = [];
            }
        }
        init(data) {
            if (data) {
                this.setID = data["setID"];
                if (data["matches"] && data["matches"].constructor === Array) {
                    this.matches = [];
                    for (let item of data["matches"])
                        this.matches.push(MatchForm.fromJS(item));
                }
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new SubmitRequest();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["setID"] = this.setID;
            if (this.matches && this.matches.constructor === Array) {
                data["matches"] = [];
                for (let item of this.matches)
                    data["matches"].push(item.toJSON());
            }
            return data;
        }
    }
    ClimbClient.SubmitRequest = SubmitRequest;
    class MatchForm {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
            if (!data) {
                this.player1Characters = [];
                this.player2Characters = [];
            }
        }
        init(data) {
            if (data) {
                this.player1Score = data["player1Score"];
                this.player2Score = data["player2Score"];
                if (data["player1Characters"] && data["player1Characters"].constructor === Array) {
                    this.player1Characters = [];
                    for (let item of data["player1Characters"])
                        this.player1Characters.push(item);
                }
                if (data["player2Characters"] && data["player2Characters"].constructor === Array) {
                    this.player2Characters = [];
                    for (let item of data["player2Characters"])
                        this.player2Characters.push(item);
                }
                this.stageID = data["stageID"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new MatchForm();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["player1Score"] = this.player1Score;
            data["player2Score"] = this.player2Score;
            if (this.player1Characters && this.player1Characters.constructor === Array) {
                data["player1Characters"] = [];
                for (let item of this.player1Characters)
                    data["player1Characters"].push(item);
            }
            if (this.player2Characters && this.player2Characters.constructor === Array) {
                data["player2Characters"] = [];
                for (let item of this.player2Characters)
                    data["player2Characters"].push(item);
            }
            data["stageID"] = this.stageID;
            return data;
        }
    }
    ClimbClient.MatchForm = MatchForm;
    class SetRequestDto {
        constructor(data) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        this[property] = data[property];
                }
            }
        }
        init(data) {
            if (data) {
                this.id = data["id"];
                this.leagueID = data["leagueID"];
                this.requesterID = data["requesterID"];
                this.challengedID = data["challengedID"];
                this.dateCreated = data["dateCreated"] ? new Date(data["dateCreated"].toString()) : undefined;
                this.setID = data["setID"];
                this.isOpen = data["isOpen"];
                this.message = data["message"];
            }
        }
        static fromJS(data) {
            data = typeof data === 'object' ? data : {};
            let result = new SetRequestDto();
            result.init(data);
            return result;
        }
        toJSON(data) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.id;
            data["leagueID"] = this.leagueID;
            data["requesterID"] = this.requesterID;
            data["challengedID"] = this.challengedID;
            data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : undefined;
            data["setID"] = this.setID;
            data["isOpen"] = this.isOpen;
            data["message"] = this.message;
            return data;
        }
    }
    ClimbClient.SetRequestDto = SetRequestDto;
    class SwaggerException extends Error {
        constructor(message, status, response, headers, result) {
            super();
            this.isSwaggerException = true;
            this.message = message;
            this.status = status;
            this.response = response;
            this.headers = headers;
            this.result = result;
        }
        static isSwaggerException(obj) {
            return obj.isSwaggerException === true;
        }
    }
    ClimbClient.SwaggerException = SwaggerException;
    function throwException(message, status, response, headers, result) {
        if (result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, headers, null);
    }
})(ClimbClient || (ClimbClient = {}));
